================================================================================
                    GO STRUCT PATTERNS - REAL-WORLD USE CASES
================================================================================

This file documents practical use cases for the struct patterns demonstrated
in this project.

================================================================================
1. FACTORY PATTERN (NewInstructor, NewWorkshop)
================================================================================

Use Case 1: Validation & Defaults
----------------------------------
Ensure data is valid before creating objects and set default values.

Example:
    func NewUser(email string, age int) (*User, error) {
        if !isValidEmail(email) {
            return nil, errors.New("invalid email")
        }
        if age < 18 {
            return nil, errors.New("must be 18+")
        }
        return &User{
            Email:     email,
            Age:       age,
            CreatedAt: time.Now(),    // automatic timestamp
            Status:    "active",      // default value
            Role:      "user",        // default role
        }, nil
    }

Real-world applications:
    - User registration systems
    - Account creation with business rules
    - Form validation before database insertion


Use Case 2: Database Connections
---------------------------------
Hide complexity of connection setup and configuration.

Example:
    func NewDatabase(config DBConfig) (*Database, error) {
        conn, err := sql.Open(config.Driver, config.ConnectionString)
        if err != nil {
            return nil, err
        }
        conn.SetMaxOpenConns(config.MaxConnections)
        conn.SetMaxIdleConns(config.MaxIdleConnections)
        conn.SetConnMaxLifetime(time.Hour)

        // Test the connection
        if err := conn.Ping(); err != nil {
            return nil, err
        }

        return &Database{conn: conn, logger: config.Logger}, nil
    }

Real-world applications:
    - Database connection pools
    - Redis/cache client initialization
    - Connection management with retry logic


Use Case 3: API Clients
------------------------
Centralized initialization with sensible defaults.

Example:
    func NewStripeClient(apiKey string) *StripeClient {
        return &StripeClient{
            apiKey:     apiKey,
            baseURL:    "https://api.stripe.com/v1",
            httpClient: &http.Client{Timeout: 30 * time.Second},
            retryCount: 3,
        }
    }

    func NewGitHubClient(token string, opts ...ClientOption) *GitHubClient {
        client := &GitHubClient{
            token:   token,
            baseURL: "https://api.github.com",
            timeout: 10 * time.Second,
        }
        // Apply optional configurations
        for _, opt := range opts {
            opt(client)
        }
        return client
    }

Real-world applications:
    - Payment gateway integrations (Stripe, PayPal)
    - Third-party API clients (GitHub, Slack, AWS)
    - Microservice communication clients


================================================================================
2. STRUCT EMBEDDING (Workshop embeds Course and Instructor)
================================================================================

Use Case 1: Base Models with Timestamps
----------------------------------------
Common pattern in database models - all tables need ID and timestamps.

Example:
    type BaseModel struct {
        ID        int       `json:"id" db:"id"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
        UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
        DeletedAt *time.Time `json:"-" db:"deleted_at"` // soft delete
    }

    type User struct {
        BaseModel                    // Inherits ID, timestamps
        Email     string `json:"email" db:"email"`
        Password  string `json:"-" db:"password"`
    }

    type Product struct {
        BaseModel                    // Same inherited fields
        Name      string  `json:"name" db:"name"`
        Price     float64 `json:"price" db:"price"`
    }

    type Order struct {
        BaseModel                    // Reuse everywhere
        UserID    int     `json:"user_id" db:"user_id"`
        Total     float64 `json:"total" db:"total"`
    }

Real-world applications:
    - ORM models (GORM, SQLBoiler)
    - API response structures
    - Audit logging for all entities


Use Case 2: HTTP Middleware & Logging
--------------------------------------
Embed common functionality across handlers.

Example:
    type Logger struct {
        logLevel string
        output   io.Writer
    }

    func (l Logger) Info(msg string) {
        fmt.Fprintf(l.output, "[INFO] %s\n", msg)
    }

    func (l Logger) Error(msg string) {
        fmt.Fprintf(l.output, "[ERROR] %s\n", msg)
    }

    type APIHandler struct {
        Logger                       // Embed logging
        db     *sql.DB
        router *mux.Router
    }

    func (h APIHandler) HandleRequest(w http.ResponseWriter, r *http.Request) {
        h.Info("Processing request")  // Use embedded logger method
        // ... handle request
    }

Real-world applications:
    - HTTP handlers with shared logging
    - Service layers with common dependencies
    - Middleware composition


Use Case 3: Role-Based Permissions
-----------------------------------
Build specialized types from base types.

Example:
    type User struct {
        ID       int
        Username string
        Email    string
    }

    func (u User) CanViewProfile() bool {
        return true  // All users can view profiles
    }

    type Admin struct {
        User                         // Admin "is a" User
        Permissions []string
        Department  string
    }

    func (a Admin) CanDeleteUser() bool {
        for _, perm := range a.Permissions {
            if perm == "delete_user" {
                return true
            }
        }
        return false
    }

    type SuperAdmin struct {
        Admin                        // SuperAdmin "is an" Admin
        AccessLevel int
    }

    func (sa SuperAdmin) CanAccessAll() bool {
        return sa.AccessLevel >= 10
    }

Real-world applications:
    - Multi-tenant systems with role hierarchies
    - Permission management systems
    - CMS with different user types


================================================================================
3. METHODS (Print(), String())
================================================================================

Use Case 1: Business Logic on Data
-----------------------------------
Encapsulate calculations and business rules.

Example:
    type Order struct {
        Items      []Item
        TaxRate    float64
        DiscountCode string
    }

    type Item struct {
        Name     string
        Price    float64
        Quantity int
    }

    func (o Order) CalculateSubtotal() float64 {
        subtotal := 0.0
        for _, item := range o.Items {
            subtotal += item.Price * float64(item.Quantity)
        }
        return subtotal
    }

    func (o Order) CalculateTax() float64 {
        return o.CalculateSubtotal() * o.TaxRate
    }

    func (o Order) ApplyDiscount() float64 {
        discount := 0.0
        if o.DiscountCode == "SAVE10" {
            discount = o.CalculateSubtotal() * 0.10
        }
        return discount
    }

    func (o Order) CalculateTotal() float64 {
        subtotal := o.CalculateSubtotal()
        tax := o.CalculateTax()
        discount := o.ApplyDiscount()
        return subtotal + tax - discount
    }

    func (o Order) IsExpressEligible() bool {
        return o.CalculateTotal() > 25.00
    }

    func (o Order) RequiresSignature() bool {
        return o.CalculateTotal() > 500.00
    }

Real-world applications:
    - E-commerce order calculations
    - Financial transactions
    - Pricing engines


Use Case 2: Data Transformation
--------------------------------
Convert data between formats.

Example:
    type User struct {
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
        Email     string `json:"email"`
        Age       int    `json:"age"`
    }

    func (u User) FullName() string {
        return u.FirstName + " " + u.LastName
    }

    func (u User) ToJSON() ([]byte, error) {
        return json.Marshal(u)
    }

    func (u User) ToCSVRow() string {
        return fmt.Sprintf("%s,%s,%s,%d",
            u.FirstName, u.LastName, u.Email, u.Age)
    }

    func (u User) IsAdult() bool {
        return u.Age >= 18
    }

    func (u User) EmailDomain() string {
        parts := strings.Split(u.Email, "@")
        if len(parts) == 2 {
            return parts[1]
        }
        return ""
    }

Real-world applications:
    - API response formatting
    - Data export (CSV, JSON, XML)
    - Report generation


Use Case 3: Validation Methods
-------------------------------
Check data integrity and business rules.

Example:
    type CreditCard struct {
        Number     string
        ExpiryDate time.Time
        CVV        string
    }

    func (cc CreditCard) IsValid() bool {
        return cc.IsNumberValid() && !cc.IsExpired() && cc.IsCVVValid()
    }

    func (cc CreditCard) IsNumberValid() bool {
        // Luhn algorithm check
        return len(cc.Number) == 16 && cc.luhnCheck()
    }

    func (cc CreditCard) IsExpired() bool {
        return time.Now().After(cc.ExpiryDate)
    }

    func (cc CreditCard) IsCVVValid() bool {
        return len(cc.CVV) == 3 || len(cc.CVV) == 4
    }

    func (cc CreditCard) CardType() string {
        if strings.HasPrefix(cc.Number, "4") {
            return "Visa"
        } else if strings.HasPrefix(cc.Number, "5") {
            return "Mastercard"
        }
        return "Unknown"
    }

Real-world applications:
    - Payment processing validation
    - Form input validation
    - Data quality checks


================================================================================
4. STRINGER INTERFACE (Course.String())
================================================================================

Use Case 1: Debugging & Logging
--------------------------------
Clean, readable output for logs without exposing sensitive data.

Example:
    type User struct {
        ID       int
        Email    string
        Password string  // sensitive!
        APIKey   string  // sensitive!
    }

    func (u User) String() string {
        return fmt.Sprintf("User#%d <%s>", u.ID, u.Email)
        // Password and APIKey are hidden from logs
    }

    // Usage:
    log.Printf("Created: %v", user)
    // Output: "Created: User#42 <john@example.com>"

    type DatabaseConfig struct {
        Host     string
        Port     int
        Database string
        Username string
        Password string  // sensitive!
    }

    func (c DatabaseConfig) String() string {
        return fmt.Sprintf("DB<%s:%d/%s> user=%s",
            c.Host, c.Port, c.Database, c.Username)
        // Password is hidden
    }

Real-world applications:
    - Secure logging (hide passwords, tokens)
    - Debugging without exposing secrets
    - Audit trails


Use Case 2: API Error Responses
--------------------------------
Human-readable error messages.

Example:
    type APIError struct {
        Code       int
        Message    string
        RequestID  string
        Timestamp  time.Time
    }

    func (e APIError) String() string {
        return fmt.Sprintf("[%d] %s (RequestID: %s)",
            e.Code, e.Message, e.RequestID)
    }

    func (e APIError) Error() string {
        return e.String()  // Implement error interface
    }

    type ValidationError struct {
        Field   string
        Message string
    }

    func (v ValidationError) String() string {
        return fmt.Sprintf("Validation failed: %s - %s", v.Field, v.Message)
    }

Real-world applications:
    - RESTful API error handling
    - Validation error messages
    - User-friendly error display


Use Case 3: Status & State Representation
------------------------------------------
Display current state in readable format.

Example:
    type JobStatus string

    const (
        JobPending   JobStatus = "pending"
        JobRunning   JobStatus = "running"
        JobCompleted JobStatus = "completed"
        JobFailed    JobStatus = "failed"
    )

    type Job struct {
        ID        int
        Name      string
        Status    JobStatus
        Progress  int
        StartedAt time.Time
    }

    func (j Job) String() string {
        if j.Status == JobRunning {
            return fmt.Sprintf("Job[%d] '%s' - %d%% complete",
                j.ID, j.Name, j.Progress)
        }
        return fmt.Sprintf("Job[%d] '%s' - %s",
            j.ID, j.Name, j.Status)
    }

Real-world applications:
    - Background job monitoring
    - Task queue status display
    - Progress tracking


================================================================================
5. COMPOSITION (Course contains Instructor)
================================================================================

Use Case 1: E-Commerce System
------------------------------
Build complex objects from simpler ones.

Example:
    type Address struct {
        Street  string
        City    string
        State   string
        Zip     string
        Country string
    }

    func (a Address) IsInternational() bool {
        return a.Country != "US"
    }

    type Customer struct {
        ID              int
        Name            string
        Email           string
        ShippingAddress Address
        BillingAddress  Address
    }

    func (c Customer) NeedsSeparateBilling() bool {
        return c.ShippingAddress != c.BillingAddress
    }

    type Item struct {
        ProductID int
        Name      string
        Price     float64
        Quantity  int
    }

    type Order struct {
        ID          int
        Customer    Customer
        Items       []Item
        Total       float64
        Status      string
        CreatedAt   time.Time
    }

    func (o Order) ShippingCost() float64 {
        if o.Customer.ShippingAddress.IsInternational() {
            return 25.00
        }
        return 5.00
    }

Real-world applications:
    - Shopping cart systems
    - Order management
    - Customer relationship management


Use Case 2: Social Media Application
-------------------------------------
Nested relationships between entities.

Example:
    type User struct {
        ID        int
        Username  string
        Avatar    string
        Bio       string
        Verified  bool
    }

    func (u User) DisplayName() string {
        if u.Verified {
            return u.Username + " âœ“"
        }
        return u.Username
    }

    type Comment struct {
        ID        int
        Content   string
        Author    User
        Likes     int
        CreatedAt time.Time
    }

    type Post struct {
        ID        int
        Content   string
        Author    User
        Likes     []User
        Comments  []Comment
        CreatedAt time.Time
        EditedAt  *time.Time
    }

    func (p Post) LikesCount() int {
        return len(p.Likes)
    }

    func (p Post) IsLikedBy(userID int) bool {
        for _, user := range p.Likes {
            if user.ID == userID {
                return true
            }
        }
        return false
    }

    func (p Post) WasEdited() bool {
        return p.EditedAt != nil
    }

Real-world applications:
    - Social networks (Twitter, Facebook)
    - Comment systems
    - Content management


Use Case 3: Configuration Management
-------------------------------------
Complex nested configurations.

Example:
    type DatabaseConfig struct {
        Host     string
        Port     int
        Username string
        Password string
        Database string
    }

    type RedisConfig struct {
        Host     string
        Port     int
        Password string
    }

    type LogConfig struct {
        Level      string
        Format     string
        OutputPath string
    }

    type ServerConfig struct {
        Port    int
        Timeout time.Duration
    }

    type AppConfig struct {
        Environment string
        Database    DatabaseConfig
        Redis       RedisConfig
        Logging     LogConfig
        Server      ServerConfig
    }

    func (c AppConfig) IsDevelopment() bool {
        return c.Environment == "development"
    }

    func (c AppConfig) IsProduction() bool {
        return c.Environment == "production"
    }

Real-world applications:
    - Application configuration
    - Microservices settings
    - Environment-specific configs


================================================================================
SUMMARY: WHERE THESE PATTERNS ARE USED IN PRODUCTION
================================================================================

1. Web Applications & APIs
   - REST APIs with models, validation, serialization
   - GraphQL resolvers with embedded data loaders
   - Middleware composition for auth, logging, metrics

2. Database ORMs
   - GORM models with hooks and associations
   - SQLBoiler generated structs
   - BaseModel patterns for timestamps and soft deletes

3. Cloud Services & Infrastructure
   - AWS SDK clients (S3Client, DynamoDBClient)
   - Kubernetes controllers and operators
   - Docker container configurations

4. Popular Open Source Projects
   - Docker: container, image, network structs
   - Kubernetes: Pod, Service, Deployment specs
   - Prometheus: metrics collectors with embedded exporters
   - Hugo: page, site, content structs

5. Business Applications
   - E-commerce platforms (order processing)
   - Payment systems (transaction handling)
   - CRM systems (customer management)
   - Inventory management

6. System Tools
   - CLI applications (Cobra, cli package)
   - Configuration management
   - Log aggregation and analysis

================================================================================
BEST PRACTICES
================================================================================

1. Use factory functions when:
   - Validation is needed
   - Default values should be set
   - Initialization is complex

2. Use embedding when:
   - You want inheritance-like behavior
   - Common fields/methods are shared
   - Building hierarchies (BaseModel pattern)

3. Use composition when:
   - Relationships are "has-a" not "is-a"
   - You need flexibility to swap components
   - Building complex objects from simple ones

4. Implement String() when:
   - Struct will be logged or debugged
   - Custom display format is needed
   - Sensitive data should be hidden

5. Add methods when:
   - Logic operates on the struct's data
   - Encapsulation improves readability
   - Behavior belongs to the type

================================================================================
